import math
import nazca as nd
import numpy as np
import nazca.geometries as geom
from nazca.interconnects import Interconnect
import scipy.integrate as integrate
import matplotlib.pyplot as plt
import spiral_lib as spi


#======================================================================
# Generate spiral pattern
#======================================================================

#======================================================================
# Archimedean spiral
#======================================================================

ROC = 3.2


#======================================================================
# Central generalized clothoid
#======================================================================

# starting point
(x0_in, y0_in) = (0, 0)

# connection point
(x1_in, y1_in) = (ROC, 1.8)
k1_in = 0
dk1_in = 0
th1_in = np.pi/2

# new instance of a 3rd-order clothoid for the central S-bend
cloth3 = spi.Clothoid_order3(x0_in, y0_in,
                             x1_in, y1_in,
                             k1_in, dk1_in, th1_in
                             )

# generate the etch holes; rectangular pattern
def rectPattern(length, width):
    holePattern = np.array([[-width/2.0, -length/2.0],
                      [-width/2.0, length/2.0],
                      [width/2.0, length/2.0],
                      [width/2.0, -length/2.0]              
                    ])
    return holePattern



# generate the etch holes, circular pattern
def circPattern(radius):
    holePattern = nd.geom.circle(radius=radius, N=32)
    return holePattern



# Place the wg element with/without holes
def place(xWg, yWg, sWg, widthWg, pointsHole, layer1, layer2, \
                  holeFlag, left, right, period, dist):
    
    #pointsWg = [(xWg[i]*1000, yWg[i]*1000) for i in range(np.shape(xWg)[0])]
    #nd.Polyline(points=pointsWg, layer = layer1, width=widthWg).put()
    
    if (holeFlag == 1):
        # new instance of holes
        hol = spi.holes(xWg, yWg, sWg, period, dist)

        hol.drill(0.0, 'Central')
        
        if (left == 1):
            for i in range(hol.lx.shape[0]):
                nd.Polygon(points = pointsHole, layer=layer1).\
                put(hol.lx[i]*1000, hol.ly[i]*1000, hol.lth[i]*180/np.pi)
        
        if (right == 1):
            for i in range(hol.rx.shape[0]):
                nd.Polygon(points = pointsHole, layer=layer1).\
                put(hol.rx[i]*1000, hol.ry[i]*1000, hol.rth[i]*180/np.pi)
            
                

# create a parametrized building block 1
def RibWgHole(xWg, yWg, sWg, widthWg=4.5, \
              radius=1.55/2, period=2, dist=((math.sqrt(3))*2), holeFlag=1): # make changes here
    with nd.Cell('spiralRib') as mycp:
        Holes = circPattern(radius)
        f=1

       # place(xWg, yWg, sWg, widthWg, Holes, 'layer1', 'layer2', \
                  #holeFlag, 1, 1, period, dist+((math.sqrt(3))*0))
        for f in range(1,9):
            g=2*f
            place(xWg, yWg, sWg, widthWg, Holes, 'layer1', 'layer2', \
                  holeFlag, 1, 1, period, dist+((math.sqrt(3))*g))
            f=f+1
    return mycp



# Place the wg element with/without holes
def place1(xWg, yWg, sWg, widthWg, pointsHole, layer1, layer2, \
                  holeFlag, left, right, period, dist):
    
    #pointsWg = [(xWg[i]*1000, yWg[i]*1000) for i in range(np.shape(xWg)[0])]
    #nd.Polyline(points=pointsWg, layer = layer1, width=widthWg).put()
    
    if (holeFlag == 0):
        # new instance of holes
        hol = spi.holes(xWg, yWg, sWg, period, dist)

        hol.drill(0.001,'Central')
        
        if (left == 0):
            for i in range(hol.lx.shape[0]):
                nd.Polygon(points = pointsHole, layer=layer2).\
                put(hol.lx[i]*1000, hol.ly[i]*1000, hol.lth[i]*180/np.pi)
        
        if (right == 0):
            for i in range(hol.rx.shape[0]):
                nd.Polygon(points = pointsHole, layer=layer2).\
                put(hol.rx[i]*1000, hol.ry[i]*1000, hol.rth[i]*180/np.pi)
                

# create a parametrized building block 2
def RibWgHole1(xWg, yWg, sWg, widthWg=4.5, \
              radius=1.55/2, period=2, dist=((math.sqrt(3))*2), holeFlag=0): # make changes here
    with nd.Cell('spiralRib1') as mycp:
        Holes = circPattern(radius)
        
        ff=0
        for ff in range (0,9):
            gg=(2*ff)+1
            place1(xWg, yWg, sWg, widthWg, Holes, 'layer1', 'layer2', \
                  holeFlag, 0, 0, period, dist+((math.sqrt(3))*gg))
            ff=ff+1
    return mycp

        
# insert your initial estimates
a3_in_est = 0.011
s1_in_est = 7.5

# author's note
""" I found that the best practice to find the parameters estimates
is by plotting x and y and just observing the resulting curve;
Once you think it looks good, go for it. The script also appears
to be sort of robust, so it partially corrects for your eventual
inability to guess.

This in fact leaves some space for further development; A GUI would be
of quite some use later in order to ease up the examination. """
# back to the business

# solve for a3 and s1, then claculate the rest and print all...
cloth3.solve_eq_xy(a3_in_est, s1_in_est)

print("Here we have the parameters for the central S-bend clothoid:"
      "\na1 = %s\na2 = %s\na3 = %s\nth0 = %s\ns1 = %s"
      % (cloth3.a1, cloth3.a2, cloth3.a3, cloth3.th0, cloth3.s1)
      )


#======================================================================
# Input/output straight extensions
#======================================================================

th0_out = - (1/2.0) * np.pi
 
(x0_out, y0_out) = (ROC, 6)
 
l_ext = np.linalg.norm(np.array([x0_out, y0_out]) - np.array([x1_in, y1_in]))+1
 
s_ext = np.linspace(0, l_ext, 2)
 
x_ext = s_ext * np.cos(-th0_out) + x1_in
y_ext = s_ext * np.sin(-th0_out) + y1_in


#======================================================================
# Input vectors for retrieving all the (x,y) coordinates
#======================================================================

s_in = np.linspace(0,
                   cloth3.s1,
                  1000
                   )


# this is a good spot to include the overall rotation
#spi.rot = np.pi / 2.0


#======================================================================
# Match curves and create a single one
#======================================================================

# new instance of curve

crv=spi.curve(cloth3.x(s_in),
              cloth3.y(s_in),
              s_in)


# add the input/output straight extensions
crv.read_next(x_ext,
              y_ext,
              s_in[-1] + s_ext
              )

#crh.match('Last')
crv.splice('Last')

crv.mirror()

length00t = spi.length(crv.x, crv.y)
length15t = np.round((length00t/10.0-0.4), 2) # in cm with 2 decimals

#======================================================================
# Clone curve and create a new one
#======================================================================
# clone curve
x, y, s = crv.clone(0)
# new instance of curve
crv2 = spi.curve(x, y, s)

# clear out all cell references
nd.clear_layout()
# clear out layers from memory
nd.clear_layers()
# clear out xsections from memory
nd.clear_xsections()

# create a layer and define its accuracy
nd.add_layer(name='layer0', layer=0, accuracy=0.001)
nd.add_layer(name='layer1', layer=1, accuracy=0.001)
nd.add_layer(name='layer2', layer=2, accuracy=0.001)

#circle = nd.Polygon(layer='layer0', points=nd.geom.ring(radius=50000, width=10, N=200))
#RibWgHole(crv.x, crv.y, crv.s, holeFlag = 1).put()
#RibWgHole1(crv2.x, crv2.y, crv2.s, holeFlag = 0).put()

RibWgHole(crv.x, crv.y, crv.s, holeFlag = 1).put(300,-1500)
RibWgHole1(crv2.x, crv2.y, crv2.s, holeFlag = 0).put(300,-1500)

RibWgHole(crv.x, crv.y, crv.s, holeFlag = 1).put(-300,1500)
RibWgHole1(crv2.x, crv2.y, crv2.s, holeFlag = 0).put(-300,1500)

#======================================================================
# Add straight waveguides
#======================================================================
# define the period in x and y
a=2 # along the waveguide
b=(math.sqrt(3))*a # across the waveguide
#define the beginning of rows in x and y
c=0 #beginning of the first hole column
m=0.5 # beginning of the second column displaced by half a period (to form triangular lattice)
#numbers of holes
d=22 #no of holes from the first of the PhC on one side of the waveguide to first of the one on the other side
s=4700 #no of holes between the beginnings of the PhC of 2 consecutive waveguides
p=5498 #no of holes between the beginnings of two groups of waveguides with different d
#sizes
l=6000 #length in number of holes
rr=1.55 #initial diameter
#g=0 # waveguide cluster
r=0 #step of increase of radius

# define the hole
def hole1(d=rr, points=50,layer=0):
    hole_shape = nd.geometries.circle(radius=d/2, N=points)
    with nd.Cell('hole') as cell:
        nd.Polygon(points=hole_shape, layer=layer).put(-9600,-6000)
    return cell

for x in range(0,2):
  # Waveguide 1
  # plot for each placement of holes
  hole1(layer=1).put(((x*s)*b/2)+(p*1), c*a, array=[9, [b, 0], l, [0, a]])
  hole1(layer=1).put(((x*s+1)*b/2)+(p*1), m*a, array=[8, [b, 0], l, [0, a]])
  # plot the other PhC mirror, 5 holes away
  hole1(layer=1).put((((x*s)+d)*b/2)+(p*1), c*a, array=[9, [b, 0], l, [0, a]])
  hole1(layer=1).put((((x*s)+(d+1))*b/2)+(p*1), m*a, array=[8, [b, 0], l, [0, a]])

#======================================================================
# Add breaking points
#======================================================================
"""
#nd.strt(length=200, width=2, layer=0).put(-4170, -5001)
nd.strt(length=2, width=52, layer=0).put(-4168, -5028)
nd.strt(length=2, width=52, layer=0).put(-4138, -5028)
nd.strt(length=2, width=52, layer=0).put(-4108, -5028)
nd.strt(length=2, width=52, layer=0).put(-4032, -5028)
nd.strt(length=2, width=52, layer=0).put(-4002, -5028)
nd.strt(length=2, width=52, layer=0).put(-3972, -5028)


#nd.strt(length=200, width=2, layer=0).put(-3600, -5001)
nd.strt(length=2, width=52, layer=0).put(-3598, -5028)
nd.strt(length=2, width=52, layer=0).put(-3568, -5028)
nd.strt(length=2, width=52, layer=0).put(-3538, -5028)
nd.strt(length=2, width=52, layer=0).put(-3464, -5028)
nd.strt(length=2, width=52, layer=0).put(-3434, -5028)
nd.strt(length=2, width=52, layer=0).put(-3404, -5028)

#nd.strt(length=200, width=2, layer=0).put(-3000, -5001)
nd.strt(length=2, width=52, layer=0).put(-2998, -5028)
nd.strt(length=2, width=52, layer=0).put(-2968, -5028)
nd.strt(length=2, width=52, layer=0).put(-2938, -5028)
nd.strt(length=2, width=52, layer=0).put(-2864, -5028)
nd.strt(length=2, width=52, layer=0).put(-2834, -5028)
nd.strt(length=2, width=52, layer=0).put(-2804, -5028)

#nd.strt(length=200, width=2, layer=0).put(3970, -5001)
nd.strt(length=2, width=52, layer=0).put(3974, -5028)
nd.strt(length=2, width=52, layer=0).put(4004, -5028)
nd.strt(length=2, width=52, layer=0).put(4034, -5028)
nd.strt(length=2, width=52, layer=0).put(4104, -5028)
nd.strt(length=2, width=52, layer=0).put(4134, -5028)
nd.strt(length=2, width=52, layer=0).put(4164, -5028)

nd.strt(length=20000, width=2, layer=0).put(-10000, -5001)
nd.strt(length=20000, width=50, layer=2).put(-10000, -5079)

#nd.strt(length=200, width=2, layer=0).put(-4170, 5001)
nd.strt(length=2, width=52, layer=0).put(-4168, 5028)
nd.strt(length=2, width=52, layer=0).put(-4138, 5028)
nd.strt(length=2, width=52, layer=0).put(-4108, 5028)
nd.strt(length=2, width=52, layer=0).put(-4032, 5028)
nd.strt(length=2, width=52, layer=0).put(-4002, 5028)
nd.strt(length=2, width=52, layer=0).put(-3972, 5028)

#nd.strt(length=200, width=2, layer=0).put(3400, 5001)
nd.strt(length=2, width=52, layer=0).put(3402, 5028)
nd.strt(length=2, width=52, layer=0).put(3432, 5028)
nd.strt(length=2, width=52, layer=0).put(3462, 5028)
nd.strt(length=2, width=52, layer=0).put(3536, 5028)
nd.strt(length=2, width=52, layer=0).put(3566, 5028)
nd.strt(length=2, width=52, layer=0).put(3596, 5028)

#nd.strt(length=200, width=2, layer=0).put(2800, 5001)
nd.strt(length=2, width=52, layer=0).put(2802, 5028)
nd.strt(length=2, width=52, layer=0).put(2832, 5028)
nd.strt(length=2, width=52, layer=0).put(2862, 5028)
nd.strt(length=2, width=52, layer=0).put(2936, 5028)
nd.strt(length=2, width=52, layer=0).put(2966, 5028)
nd.strt(length=2, width=52, layer=0).put(2996, 5028)

#nd.strt(length=200, width=2, layer=0).put(3970, 5001)
nd.strt(length=2, width=52, layer=0).put(3974, 5028)
nd.strt(length=2, width=52, layer=0).put(4004, 5028)
nd.strt(length=2, width=52, layer=0).put(4034, 5028)
nd.strt(length=2, width=52, layer=0).put(4108, 5028)
nd.strt(length=2, width=52, layer=0).put(4138, 5028)
nd.strt(length=2, width=52, layer=0).put(4168, 5028)

nd.strt(length=20000, width=2, layer=0).put(-10000, 5001)
nd.strt(length=20000, width=50, layer=2).put(-10000, 5079)

nd.strt(length=50, width=20000, layer=2).put(-5050, 0)
nd.strt(length=50, width=20000, layer=2).put(5000, 0)

# chip edges
#nd.strt(length=25000, width=5, layer=1).put(-12500, -12500)
#nd.strt(length=25000, width=5, layer=1).put(-12500, 12500)
#nd.strt(length=5, width=25000, layer=1).put(-12500, 0)
#nd.strt(length=5, width=25000, layer=1).put(12500, 0)
"""
# create a marker cross
def cross(thickness=100, width=1000, aspect=1, nameWg='Cross'): # make changes here
    with nd.Cell(name=nameWg) as mycp:
        pointsCross = ([-width/2.0, thickness/2.0],
                       [-thickness/2.0, thickness/2.0],
                       [-thickness/2.0, width/2.0],
                       [thickness/2.0, width/2.0],
                       [thickness/2.0, thickness/2.0],
                       [width/2.0, thickness/2.0],
                       [width/2.0, -thickness/2.0],
                       [thickness/2.0, -thickness/2.0],
                       [thickness/2.0, -width/2.0],
                       [-thickness/2.0, -width/2.0],
                       [-thickness/2.0, -thickness/2.0],
                       [-width/2.0, -thickness/2.0]
                      )
        
        nd.Polygon(points=pointsCross, layer = 3).put()   
    return mycp

cross().put(7525,11000)
cross().put(-7525,11000)
cross().put(7525,-11000)
cross().put(-7525,-11000)

cross().put(7000,5079)
cross().put(7000,-5079)
cross().put(-7000,5079)
cross().put(-7000,-5079)

nd.export_gds(filename="20mm.gds")
